// Goki smart wallet program.
// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package smartwallet

import (
	"bytes"
	"fmt"
	ag_spew "github.com/davecgh/go-spew/spew"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
	ag_text "github.com/gagliardetto/solana-go/text"
	ag_treeout "github.com/gagliardetto/treeout"
)

var ProgramID ag_solanago.PublicKey

func SetProgramID(pubkey ag_solanago.PublicKey) {
	ProgramID = pubkey
	ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
}

const ProgramName = "Smartwallet"

func init() {
	if !ProgramID.IsZero() {
		ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
	}
}

var (
	// Initializes a new [SmartWallet] account with a set of owners and a threshold.
	Instruction_CreateSmartWallet = ag_binary.TypeID([8]byte{129, 39, 235, 18, 132, 68, 203, 19})

	// Sets the owners field on the smart_wallet. The only way this can be invoked
	// is via a recursive call from execute_transaction -> set_owners.
	Instruction_SetOwners = ag_binary.TypeID([8]byte{134, 145, 42, 122, 94, 64, 76, 218})

	// Changes the execution threshold of the smart_wallet. The only way this can be
	// invoked is via a recursive call from execute_transaction ->
	// change_threshold.
	Instruction_ChangeThreshold = ag_binary.TypeID([8]byte{146, 151, 213, 63, 121, 79, 9, 29})

	// Creates a new [Transaction] account, automatically signed by the creator,
	// which must be one of the owners of the smart_wallet.
	Instruction_CreateTransaction = ag_binary.TypeID([8]byte{227, 193, 53, 239, 55, 126, 112, 105})

	// Creates a new [Transaction] account with time delay.
	Instruction_CreateTransactionWithTimelock = ag_binary.TypeID([8]byte{93, 252, 41, 108, 86, 76, 89, 237})

	// Approves a transaction on behalf of an owner of the [SmartWallet].
	Instruction_Approve = ag_binary.TypeID([8]byte{69, 74, 217, 36, 115, 117, 97, 76})

	// Unapproves a transaction on behalf of an owner of the [SmartWallet].
	Instruction_Unapprove = ag_binary.TypeID([8]byte{5, 92, 229, 161, 250, 166, 122, 171})

	// Executes the given transaction if threshold owners have signed it.
	Instruction_ExecuteTransaction = ag_binary.TypeID([8]byte{231, 173, 49, 91, 235, 24, 68, 19})

	// Executes the given transaction signed by the given derived address,
	// if threshold owners have signed it.
	// This allows a Smart Wallet to receive SOL.
	Instruction_ExecuteTransactionDerived = ag_binary.TypeID([8]byte{121, 1, 232, 181, 156, 185, 93, 88})

	// Invokes an arbitrary instruction as a PDA derived from the owner,
	// i.e. as an "Owner Invoker".
	//
	// This is useful for using the multisig as a whitelist or as a council,
	// e.g. a whitelist of approved owners.
	Instruction_OwnerInvokeInstruction = ag_binary.TypeID([8]byte{204, 35, 69, 185, 159, 100, 140, 165})

	// Invokes an arbitrary instruction as a PDA derived from the owner,
	// i.e. as an "Owner Invoker".
	//
	// This is useful for using the multisig as a whitelist or as a council,
	// e.g. a whitelist of approved owners.
	//
	// # Arguments
	// - `index` - The index of the owner-invoker.
	// - `bump` - Bump seed of the owner-invoker.
	// - `invoker` - The owner-invoker.
	// - `data` - The raw bytes of the instruction data.
	Instruction_OwnerInvokeInstructionV2 = ag_binary.TypeID([8]byte{169, 161, 80, 52, 188, 19, 232, 97})

	// Creates a struct containing a reverse mapping of a subaccount to a
	// [SmartWallet].
	Instruction_CreateSubaccountInfo = ag_binary.TypeID([8]byte{196, 132, 49, 16, 91, 57, 67, 139})
)

// InstructionIDToName returns the name of the instruction given its ID.
func InstructionIDToName(id ag_binary.TypeID) string {
	switch id {
	case Instruction_CreateSmartWallet:
		return "CreateSmartWallet"
	case Instruction_SetOwners:
		return "SetOwners"
	case Instruction_ChangeThreshold:
		return "ChangeThreshold"
	case Instruction_CreateTransaction:
		return "CreateTransaction"
	case Instruction_CreateTransactionWithTimelock:
		return "CreateTransactionWithTimelock"
	case Instruction_Approve:
		return "Approve"
	case Instruction_Unapprove:
		return "Unapprove"
	case Instruction_ExecuteTransaction:
		return "ExecuteTransaction"
	case Instruction_ExecuteTransactionDerived:
		return "ExecuteTransactionDerived"
	case Instruction_OwnerInvokeInstruction:
		return "OwnerInvokeInstruction"
	case Instruction_OwnerInvokeInstructionV2:
		return "OwnerInvokeInstructionV2"
	case Instruction_CreateSubaccountInfo:
		return "CreateSubaccountInfo"
	default:
		return ""
	}
}

type Instruction struct {
	ag_binary.BaseVariant
}

func (inst *Instruction) EncodeToTree(parent ag_treeout.Branches) {
	if enToTree, ok := inst.Impl.(ag_text.EncodableToTree); ok {
		enToTree.EncodeToTree(parent)
	} else {
		parent.Child(ag_spew.Sdump(inst))
	}
}

var InstructionImplDef = ag_binary.NewVariantDefinition(
	ag_binary.AnchorTypeIDEncoding,
	[]ag_binary.VariantType{
		{
			"create_smart_wallet", (*CreateSmartWallet)(nil),
		},
		{
			"set_owners", (*SetOwners)(nil),
		},
		{
			"change_threshold", (*ChangeThreshold)(nil),
		},
		{
			"create_transaction", (*CreateTransaction)(nil),
		},
		{
			"create_transaction_with_timelock", (*CreateTransactionWithTimelock)(nil),
		},
		{
			"approve", (*Approve)(nil),
		},
		{
			"unapprove", (*Unapprove)(nil),
		},
		{
			"execute_transaction", (*ExecuteTransaction)(nil),
		},
		{
			"execute_transaction_derived", (*ExecuteTransactionDerived)(nil),
		},
		{
			"owner_invoke_instruction", (*OwnerInvokeInstruction)(nil),
		},
		{
			"owner_invoke_instruction_v2", (*OwnerInvokeInstructionV2)(nil),
		},
		{
			"create_subaccount_info", (*CreateSubaccountInfo)(nil),
		},
	},
)

func (inst *Instruction) ProgramID() ag_solanago.PublicKey {
	return ProgramID
}

func (inst *Instruction) Accounts() (out []*ag_solanago.AccountMeta) {
	return inst.Impl.(ag_solanago.AccountsGettable).GetAccounts()
}

func (inst *Instruction) Data() ([]byte, error) {
	buf := new(bytes.Buffer)
	if err := ag_binary.NewBorshEncoder(buf).Encode(inst); err != nil {
		return nil, fmt.Errorf("unable to encode instruction: %w", err)
	}
	return buf.Bytes(), nil
}

func (inst *Instruction) TextEncode(encoder *ag_text.Encoder, option *ag_text.Option) error {
	return encoder.Encode(inst.Impl, option)
}

func (inst *Instruction) UnmarshalWithDecoder(decoder *ag_binary.Decoder) error {
	return inst.BaseVariant.UnmarshalBinaryVariant(decoder, InstructionImplDef)
}

func (inst *Instruction) MarshalWithEncoder(encoder *ag_binary.Encoder) error {
	err := encoder.WriteBytes(inst.TypeID.Bytes(), false)
	if err != nil {
		return fmt.Errorf("unable to write variant type: %w", err)
	}
	return encoder.Encode(inst.Impl)
}

func registryDecodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (interface{}, error) {
	inst, err := DecodeInstruction(accounts, data)
	if err != nil {
		return nil, err
	}
	return inst, nil
}

func DecodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (*Instruction, error) {
	inst := new(Instruction)
	if err := ag_binary.NewBorshDecoder(data).Decode(inst); err != nil {
		return nil, fmt.Errorf("unable to decode instruction: %w", err)
	}
	if v, ok := inst.Impl.(ag_solanago.AccountsSettable); ok {
		err := v.SetAccounts(accounts)
		if err != nil {
			return nil, fmt.Errorf("unable to set accounts for instruction: %w", err)
		}
	}
	return inst, nil
}
